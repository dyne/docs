{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the CJIT Tutorial","text":"<p>CJIT is a versatile C interpreter based on TinyCC, designed to compile C code in-memory and execute it live. This manual serves as a guide to the full potential of CJIT, empowering you to efficiently develop and test C programs in real-time.</p> <p>This tutorial will guide you through practical usage examples, helping you to swiftly integrate CJIT into your workflow. \ud83d\udcda\ud83d\udd27</p>"},{"location":"#hello-world","title":"Hello World!","text":"<p>This classic example will make you create a <code>hello.c</code> file and execute it with CJIT to print the string \"Hello World!\" in the terminal.</p> <p>Please chose the right example code using tabs: MS/Windows, Apple/OSX or GNU/Linux</p> <p>Info</p> <p>All Windows examples are made for PowerShell, on WSL then pick GNU/Linux.</p> <p>To download CJIT paste the following command in the terminal</p> MS/WindowsApple/OSXGNU/Linux <pre><code>Invoke-WebRequest -OutFile \"cjit.exe\" -Uri \"https://github.com/dyne/cjit/releases/latest/download/cjit.exe\"\n</code></pre> <pre><code>curl -sLo cjit https://github.com/dyne/cjit/releases/latest/download/cjit-$(uname)-$(uname -m)\nchmod +x cjit\n</code></pre> <pre><code>curl -sLo cjit https://github.com/dyne/cjit/releases/latest/download/cjit-$(uname)-$(uname -m)\nchmod +x cjit\n</code></pre> <p>Then create hello.c by pasting these lines in the terminal:</p> MS/WindowsApple/OSXGNU/Linux <pre><code>@\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n  fprintf(stderr,\"Hello, World!\\n\");\n  exit(0);\n}\n\"@| Out-File -FilePath \"hello.c\" -Encoding ASCII\n</code></pre> <pre><code>cat &lt;&lt; EOF &gt; hello.c\n#!/usr/bin/env cjit\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n  fprintf(stderr,\"Hello, World!\\n\");\n  exit(0);\n}\nEOF\n</code></pre> <pre><code>cat &lt;&lt; EOF &gt; hello.c\n#!/usr/bin/env cjit\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n  fprintf(stderr,\"Hello, World!\\n\");\n  exit(0);\n}\nEOF\n</code></pre> <p>Finally execute hello.c with CJIT:</p> MS/WindowsApple/OSXGNU/Linux <pre><code>.\\cjit.exe .\\hello.c\n</code></pre> <pre><code>./cjit hello.c\n</code></pre> <pre><code>./cjit hello.c\n</code></pre> <p>As a result you will see CJIT starting and printing \"Hello World!\"</p> <pre><code>CJIT v0.13.2 by Dyne.org\nHello World!\n</code></pre> <p>You can play with <code>hello.c</code>, change what you want and run it again!</p>"},{"location":"#flying-donuts","title":"Flying Donuts","text":"<p>This example will print an animated donut on the terminal!</p> <p>Create the <code>donut.c</code> file using the artful code below:</p> MS/WindowsApple/OSXGNU/Linux <pre><code>@\"\n             i,j,k,x,y,o,N;\n         main(){float z[1760],a\n      #define R(t,x,y) f=x;x-=t*y\\\n   ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f;\n   =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char\n b[1760];for(;;){memset(b,32,1760);g=0,\nh=1;memset(z,0,7040);for(j=0;j&lt;90;j++){\nG=0,H=1;for(i=0;i&lt;314;i++){A=h+2,D=1/(G*\nA*a+g*e+5);t=G*A        *e-g*a;x=40+30*D\n*(H*A*d-t*c);y=          12+15*D*(H*A*c+\nt*d);o=x+80*y;N          =8*((g*a-G*h*e)\n*d-G*h*a-g*e-H*h        *c);if(22&gt;y&amp;&amp;y&gt;\n 0&amp;&amp;x&gt;0&amp;&amp;80&gt;x&amp;&amp;D&gt;z[o]){z[o]=D;b[o]=(N&gt;0\n  ?N:0)[\".,-~:;=!*#$@\"];}R(.02,H,G);}R(\n  .07,h,g);}for(k=0;1761&gt;k;k++)putchar\n   (k%80?b[k]:10);R(.04,e,a);R(.02,d,\n     c);usleep(15000);printf('\\n'+(\n        \" donut.c! \\x1b[23A\"));}}\n          /*no math lib needed\n             .@a1k0n 2021.*/\n\"@| Out-File -FilePath \"donut.c\" -Encoding ASCII\n</code></pre> <pre><code>cat &lt;&lt; EOF &gt; donut.c\n             i,j,k,x,y,o,N;\n         main(){float z[1760],a\n      #define R(t,x,y) f=x;x-=t*y\\\n   ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f;\n   =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char\n b[1760];for(;;){memset(b,32,1760);g=0,\nh=1;memset(z,0,7040);for(j=0;j&lt;90;j++){\nG=0,H=1;for(i=0;i&lt;314;i++){A=h+2,D=1/(G*\nA*a+g*e+5);t=G*A        *e-g*a;x=40+30*D\n*(H*A*d-t*c);y=          12+15*D*(H*A*c+\nt*d);o=x+80*y;N          =8*((g*a-G*h*e)\n*d-G*h*a-g*e-H*h        *c);if(22&gt;y&amp;&amp;y&gt;\n 0&amp;&amp;x&gt;0&amp;&amp;80&gt;x&amp;&amp;D&gt;z[o]){z[o]=D;b[o]=(N&gt;0\n  ?N:0)[\".,-~:;=!*#$@\"];}R(.02,H,G);}R(\n  .07,h,g);}for(k=0;1761&gt;k;k++)putchar\n   (k%80?b[k]:10);R(.04,e,a);R(.02,d,\n     c);usleep(15000);printf('\\n'+(\n        \" donut.c! \\x1b[23A\"));}}\n          /*no math lib needed\n             .@a1k0n 2021.*/\nEOF\n</code></pre> <pre><code>cat &lt;&lt; EOF &gt; donut.c\n             i,j,k,x,y,o,N;\n         main(){float z[1760],a\n      #define R(t,x,y) f=x;x-=t*y\\\n   ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f;\n   =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char\n b[1760];for(;;){memset(b,32,1760);g=0,\nh=1;memset(z,0,7040);for(j=0;j&lt;90;j++){\nG=0,H=1;for(i=0;i&lt;314;i++){A=h+2,D=1/(G*\nA*a+g*e+5);t=G*A        *e-g*a;x=40+30*D\n*(H*A*d-t*c);y=          12+15*D*(H*A*c+\nt*d);o=x+80*y;N          =8*((g*a-G*h*e)\n*d-G*h*a-g*e-H*h        *c);if(22&gt;y&amp;&amp;y&gt;\n 0&amp;&amp;x&gt;0&amp;&amp;80&gt;x&amp;&amp;D&gt;z[o]){z[o]=D;b[o]=(N&gt;0\n  ?N:0)[\".,-~:;=!*#$@\"];}R(.02,H,G);}R(\n  .07,h,g);}for(k=0;1761&gt;k;k++)putchar\n   (k%80?b[k]:10);R(.04,e,a);R(.02,d,\n     c);usleep(15000);printf('\\n'+(\n        \" donut.c! \\x1b[23A\"));}}\n          /*no math lib needed\n             .@a1k0n 2021.*/\nEOF\n</code></pre> <p>Then make the donut fly with CJIT!</p> MS/WindowsApple/OSXGNU/Linux <pre><code>.\\cjit.exe .\\donut.c\n</code></pre> <pre><code>./cjit donut.c\n</code></pre> <pre><code>./cjit donut.c\n</code></pre> <p>Warning</p> <p>With this example and other programs, just hit CTRL+C to quit.</p> <p>The state of affairs in CJIT is well demonstrated by this example: right now the terminal is much slower on windows (rightmost donut).</p> <p></p>"},{"location":"#game-of-life","title":"Game of Life","text":"<p>Another fascinating example is the \"Game of Life,\" a cellular automaton devised by the British mathematician John Horton Conway in 1970.</p> <p>Our <code>life.c</code> example is part of the cjit-demo.tar.gz package you should download to enjoy this and other demos in this tutorial. Download, extract and copy the cjit executable inside the cjit-demo folder. Below are quick sequence of commands to do that:</p> MS/WindowsApple/OSXGNU/Linux <pre><code>Invoke-WebRequest -OutFile \"life.c\" -Uri \"https://github.com/dyne/cjit/raw/refs/heads/main/examples/life.c\"\n</code></pre> <pre><code>curl -sLo life.c https://github.com/dyne/cjit/raw/refs/heads/main/examples/life.c\n</code></pre> <pre><code>curl -sLo life.c https://github.com/dyne/cjit/raw/refs/heads/main/examples/life.c\n</code></pre> <p>Then execute the <code>life.c</code> source file passing it as argument to <code>cjit</code>, the same way it was done for the flying donut.</p> MS/WindowsApple/OSXGNU/Linux <pre><code>.\\cjit.exe life.c\n</code></pre> <pre><code>./cjit life.c\n</code></pre> <pre><code>./cjit life.c\n</code></pre> <p>Have a look around the <code>life.c</code> file with your favorite text editor and feel free to change things and see what happens.</p> <p></p>"},{"location":"#next-graphics-with-cjit","title":"\u23e9 Next: graphics with CJIT","text":"<p>Go to the next chapter of this tutorial.</p>"},{"location":"faq/","title":"Frequently Asked Questions about CJIT","text":"<p>Here we try to answer the most asked questions.</p>"},{"location":"faq/#whats-different-between-tcc-run-and-cjit","title":"What's different between <code>tcc -run</code> and CJIT?","text":"<p>The main difference is in usability.</p> <p>CJIT improves three main UX aspects for now:</p> <ol> <li> <p>It works as a single executable file which embeds the TinyCC    compiler, all its headers and its standard library. This way there    is no need to install anything system wide, check paths and setup    build folders.</p> </li> <li> <p>It supports adding multiple files into one execution: can accept    wildcards to ingest anything that is a C source, a pre-compiled    object or a shared library. The symbols exported by each file will    be visible to all during the same execution.</p> </li> <li> <p>It finds automatically common system libraries for each target    platform, avoiding the need to repeat these settings and look for    the right paths.</p> </li> </ol> <p>We are happy to further the improve developer experience with CJIT, and your advice is welcome: open an issue!</p>"},{"location":"faq/#whats-different-between-libgccjit-and-cjit","title":"What's different between <code>libgccjit</code> and CJIT?","text":"<p>CJIT is built as an command-line interpreter using the TinyCC backend for in-memory compilation. In the future it may also offer <code>libgccjit</code> as backend, as long as it will be possible to embed it all inside a single executable file, which is a core feature of CJIT's vision for developer experience.</p>"},{"location":"faq/#which-parts-of-cjit-are-licensed-under-what","title":"Which parts of CJIT are licensed, under what?","text":"<p>Detailed licensing information for CJIT is in the REUSE metadata file. We check correctness of these attributions at every single commit.</p> <p>All CJIT's original code is licensed using GNU GPL v3 and will be updated to use future versions of this license published by the Free Software Foundation. All included licenses are compatible with this.</p> <p>We grant to everyone the freedome to use, study, modify, and redistribute modifications of CJIT as long as such modifications are licensed with one of the licenses already present: MIT, GPL or LGPL.</p> <p>More information about CJIT's licensing is also found in its manpage section on LICENSING.</p>"},{"location":"faq/#where-to-i-send-my-corrections-to-this-documentation","title":"Where to I send my corrections to this documentation?","text":"<p>You are welcome to open an issue or a PR to the dyne/docs project.</p> <p>The source of the CJIT manual is in the markdown formatted files in <code>src/cjit/docs</code> inside the repository.</p>"},{"location":"faq/#i-have-a-new-question-whom-can-i-ask","title":"I have a new question, whom can I ask?","text":"<p>You are welcome to interact in public with Dyne.org hackers over any of our channels and social network acconts.</p> <p>If you prefer to interact privately, write a mail to info@dyne.org.</p>"},{"location":"filesystem/","title":"Filesystem operations","text":"<p>The dmon header is designed for monitoring changes in the filesystem: simplifies the process of tracking file modifications, deletions, and creations, allowing you to respond to these events in real time within your C scripts.</p> <p>Here is examples/dmon.c wich is tested to run on all CJIT platforms:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;dmon.h&gt;\n\nstatic void watch_callback(dmon_watch_id watch_id,\n                           dmon_action action,\n                           const char* rootdir,\n                           const char* filepath,\n                           const char* oldfilepath,\n                           void* user) {\n    (void)(user);\n    (void)(watch_id);\n    switch (action) {\n    case DMON_ACTION_CREATE:\n        fprintf(stderr,\"CREATE: [%s]%s\\n\", rootdir, filepath);\n        break;\n    case DMON_ACTION_DELETE:\n        fprintf(stderr,\"DELETE: [%s]%s\\n\", rootdir, filepath);\n        break;\n    case DMON_ACTION_MODIFY:\n        fprintf(stderr,\"MODIFY: [%s]%s\\n\", rootdir, filepath);\n        break;\n    case DMON_ACTION_MOVE:\n        fprintf(stderr,\"MOVE: [%s]%s -&gt; [%s]%s\\n\",\n          rootdir, oldfilepath, rootdir, filepath);\n        break;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc &gt; 1) {\n        dmon_init();\n        puts(\"waiting for changes ..\");\n        dmon_watch(argv[1], watch_callback,\n          DMON_WATCHFLAGS_RECURSIVE, NULL);\n        getchar();\n        dmon_deinit();\n    } else {\n        puts(\"usage: test dirname\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"filesystem/#next-terminal-user-interface","title":"\u23e9 Next: Terminal User Interface","text":"<p>Go to the next chapter of this tutorial.</p>"},{"location":"graphics/","title":"CJIT for graphical applications","text":"<p>Be welcome to the exciting world of graphical C applications using SDL (Simple DirectMedia Layer). SDL, originally developed by Sam Lantinga in 1998, is a powerful, cross-platform library designed to provide low-level access to audio, keyboard, mouse, and graphics hardware via OpenGL and Direct3D.</p> <p>Warn</p> <p>This part of the tutorial may be incomplete for Apple/OSX, please help testing and refining it!</p>"},{"location":"graphics/#download-the-cjit-demo-package","title":"Download the cjit-demo package","text":"<p>From now on this tutorial will guide you to launch more complex applications, showing how to use libraries that are installed on your system and shipped along with the source code.</p> <p>To setup the demo environment you can simply run the command below:</p> MS/WindowsApple/OSXGNU/Linux <pre><code>iex ((New-Object System.Net.WebClient).DownloadString('https://dyne.org/cjit/demo'))\n</code></pre> <pre><code>curl -sL https://dyne.org/cjit/demo.sh | bash\n</code></pre> <pre><code>curl -sL https://dyne.org/cjit/demo.sh | bash\n</code></pre>"},{"location":"graphics/#the-beauty-of-random","title":"The Beauty of Random","text":"<p>Execute sdl2_noise.c passing the source file as argument to CJIT, and since we are also using the SDL2 library we also need an extra parameter:</p> MS/WindowsApple/OSXGNU/Linux <pre><code>.\\cjit.exe examples/sdl2_noise.c SDL2.dll\n</code></pre> <pre><code>./cjit examples/sdl2_noise.c -lSDL2\n</code></pre> <pre><code>./cjit examples/sdl2_noise.c -lSDL2\n</code></pre> <p></p> <p>Info</p> <p>This preview looks blurred because video compression cannot deal well with randomness.</p> <p>Have a look inside sdl2_noise.c, and see the first line of code:</p>"},{"location":"graphics/#the-hashbang","title":"The \"hashbang\"","text":"<pre><code>#!/usr/bin/env cjit\n</code></pre> <p>The source file can be launched as a script, when the CJIT interpreter is found in PATH.</p> <p>Warning</p> <p>The hashbang works only on Apple/OSX and GNU/Linux, where scripts can be made executable with <code>chmod +x</code></p>"},{"location":"graphics/#the-pragma-lib","title":"The pragma lib","text":"<p>Also see this pre-processor directive: <pre><code>#pragma comment(lib, \"SDL2\")\n</code></pre></p> <p>This line tells CJIT to link the <code>SDL2</code> shared library. It is the equivaled of <code>SDL2.dll</code> on the commandline, with the only difference that it can be specified inside the source code.</p> <p>Info</p> <p>On Windows the DLL files need to be in the same directory of execution, or installed system-wide.</p>"},{"location":"graphics/#three-dimensions","title":"Three Dimensions","text":"<p>To draw accelerated graphics and 3D objects we'll use OpenGL libraries, which need to be installed on the system.</p> MS/WindowsApple/OSXGNU/Linux <p>Install the Windows SDK which is distributed gratis by Microsoft.</p> <p>Not sure (help testing this please!)</p> <pre><code>sudo apt-get install libopengl-dev\n</code></pre> <p>Then run CJIT passing the file [examples/opengl.c]((https://github.com/dyne/cjit/blob/main/examples/opengl.c) as argument, along with the same parameter to link SDL2.</p> <p></p> <p>For more details on using OpenGL and SDL2 in C with shaders, read the multi-platform-modern-opengl-demo-with-sdl2 tutorial on which our example code is based.</p>"},{"location":"graphics/#nuklear-widgets","title":"Nuklear widgets","text":"<p>Nuklear is a minimal, immediate-mode graphical user interface toolkit written in ANSI C and licensed under public domain. It is designed to be lightweight and highly customizable, and provides a wide range of components, including buttons, sliders, text input fields, and more, all of which can be integrated seamlessly with CJIT.</p> <p>This time the code of our example is distributed across multiple files, this is a quick overview of what is found inside the <code>example</code> folder: <pre><code>.\n\u251c\u2500\u2500 nuklear\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 calculator.c\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 canvas.c\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 node_editor.c\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 overview.c\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 style.c\n\u251c\u2500\u2500 nuklear.c\n\u2514\u2500\u2500 nuklear.h\n</code></pre></p> <p>The main code of our example is examples/nuklear.c and by default it will just start all modules.</p> <p>Fire it up as usual with <code>./cjit.exe examples/nuklear.c</code> or equivalent commands on GNU/Linux and Apple/OSX.</p> <p>And \ud83d\udca5Boom! enjoy Nuklear!</p> <p></p>"},{"location":"graphics/#next-sound-with-cjit","title":"\u23e9 Next: sound with CJIT","text":"<p>Go to the next chapter of this tutorial.</p>"},{"location":"manpage/","title":"cjit(1) - Just-In-Time interpreter for C","text":"<p>CJIT, January 2025</p> <pre><code>cjit [options] &lt;files&gt; [-- app arguments]\n\n\n\n[options] are prefixed by single or double dash and may require an argument\n\n\n\n&lt;files&gt; can be one or more paths to any source (.c), object (.o) or libs (dll, dylib, .so)\n\n\n\n[-- app args] all arguments following a double dash are passed as-is to the running application\n\n<p></p>"},{"location":"manpage/#description","title":"Description","text":"<p>CJIT\nis a lightweight C interpreter that lets you run C code\ninstantly, without needing to build it first. In addition to\njust-in-time execution, it can do everything a C compiler does,\nincluding call functions from any installed library, and generate\nexecutables. It is also designed to be a drop-in replacement for gcc(1)\nand clang(1) for instance using CC=cjit as environment setting.</p>\n<p></p>"},{"location":"manpage/#options","title":"Options","text":"<ul>\n<li>\n<p>-h\n  Displays a summary of the command-line options available with `cjit`. It is useful for users who need a quick reference on how to use the tool. This manual is meant to complete that knowledge with more in-depth information.</p>\n</li>\n<li>\n<p>-v\n  Prints the version number of `cjit`. It's helpful for verifying the specific version you're working with, especially when troubleshooting or reporting issues: always include the version output. It can also be quickly added to any commandline combination to show the internal state of cjit, for instance include and library paths configured, cflags and libraries linked.</p>\n</li>\n<li>\n<p>-q\n  Suppresses all non-essential output, providing a quieter operation. Only critical errors are displayed. This option is turned on by default when CJIT is launched inside a script (no tty).</p>\n</li>\n<li>\n<p>-C &lt;--various -C --flags&gt;\n  Use this option to specify custom flags for the interpreter or compiler. If not set, `cjit` uses the flags defined in the environment variable `CFLAGS`.</p>\n</li>\n<li>\n<p>-c\n  Only compiles a single provided source file, without executing it, to produce an object file. This option will generate a new pre-compiled object file named like the given source, changing its extension from .c to .o, unless a new name is specified using -o.</p>\n</li>\n<li>\n<p>-o &lt;filename&gt;\n  Specifies a filename output. When included in a command-line it switches CJIT to BUILD mode (see section below) and compiles all the source files into an executable but does not run the resulting program. You must provide the path for the output executable.</p>\n</li>\n<li>\n<p>-D key[=value]\n  Defines a \"macro\" key (and optionally its value) for the preprocessor, just like a #define directive would do when included inside the source. You can specify a simple symbol or use `key=value` to define a macro with a specific value.</p>\n</li>\n<li>\n<p>-I &lt;path&gt;\n  Adds a directory path to the list of paths searched for header files. This is particularly useful if your project includes headers that are not in the standard system directories, for more information see the PATHS section.</p>\n</li>\n<li>\n<p>-l &lt;name&gt;&gt;\n  Links a specific shared library. On Windows the name is that of a .DLL file without its extension. On UNIX systems (GNU/Linux and BSD) one needs to provide the name of the library without the `lib` prefix (e.g., use `-lssl` for `libssl.so`).</p>\n</li>\n<li>\n<p>-L &lt;path&gt;\n  Add a directory path to the library search paths. This is helpful when your project depends on libraries that are located in non-standard directories, for more information see the PATHS section.</p>\n</li>\n<li>\n<p>-e &lt;function&gt;\n  Specifies a different entry function than the default `main` function. It is useful if your program has multiple potential entry points, of you want to try a different one ... at your own risk.</p>\n</li>\n<li>\n<p>-p &lt;path&gt;\n  Writes the process ID of the executing program to the specified file. This is useful for managing and monitoring the running process.</p>\n</li>\n<li>\n<p>--verb\n  Enables verbose logging, which provides more detailed information about the actions CJIT is performing. It's useful for debugging and understanding the compilation and execution process.</p>\n</li>\n<li>\n<p>--xass [path]\n  Extract runtime assets required by CJIT to run you program. If a path is specified, the assets are extracted to that location; otherwise, they are extracted to the default directory, which is located in AppData\\Local\\Temp\\CJIT-vN.N.N on Windows and in /tmp/cjit-vN.N.N on POSIX systems.</p>\n</li>\n<li>\n<p>--xtgz &lt;path&gt;\n  Extracts all files from a specified USTAR format tar.gz archive. This is useful for setting up project dependencies or resources packaged in an archive, for instance is used to setup the cjit-demo.tar.gz tutorial assets by the script found on https://dyne.org/cjit/demo.</p>\n</li>\n</ul>\n<p></p>"},{"location":"manpage/#author","title":"Author","text":"<p>This manual is Copyright (c) 2025 by the Dyne.org foundation</p>\n<p>Written by Denis Roio &lt;https://jaromil.dyne.org&gt;</p>\n<p></p>"},{"location":"manpage/#licensing","title":"Licensing","text":"<p>CJIT\nis licensed under the GNU General Public License version 3 (GPLv3) or any later version published by the Free Software Foundation.\nThe GPLv3 grants you 4 freedoms:\n- Use:\nJust like anyone else, you may use this software for any purpose.\n- Study and Modify:\nYou may study how CJIT works, and modify it to make it do what you wish.\n- Distribute:\nYou may redistribute copies of CJIT so that others can benefit from it.\n- Distribute Modified Versions:\nYou may distribute your modifications if you grant others the same freedom.</p>\n<p>This is a human-readable summary of (and not a substitute for) the license. For the full text of the GPLv3 visit https://www.gnu.org/licenses/gpl-3.0.html. Components included in CJIT are copyright and licensed by their respective vendors, and all are compatible with the GPLv3: a list of component licenses is provided in CJIT's sourcecode inside the LICENSES/ folder and detailed by the REUSE.toml file.</p>\n<p>This manpage is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0) or any later version. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.</p>\n<p></p>"},{"location":"manpage/#availability","title":"Availability","text":"<p>The most recent version of CJIT sourcecode and up to date\ndocumentation is made available from its website on\nhttps://dyne.org/cjit.</p>\n<p></p>"},{"location":"manpage/#see-also","title":"See Also","text":"<p>tcc(1),</p>"},{"location":"sound/","title":"Sound operations: play and record","text":"<p>The miniaudio header handles audio playback and capture with ease: you can seamlessly integrate audio functionality into your C code, creating immersive and interactive experiences for your users.</p> <p>Miniaudio provides two main sources of documentation</p> <ul> <li>The miniaudio Programmer's manual</li> <li>Various miniaudio examples</li> </ul> <p>Miniaudio includes both low level and high level APIs. The low level API is good for those who want to do all of their mixing themselves and only require a light weight interface to the underlying audio device. The high level API is good for those who have complex mixing and effect requirements.</p> <p>In miniaudio, objects are transparent structures. Unlike many other libraries, there are no handles to opaque objects which means you need to allocate memory for objects yourself.</p> <p>A config/init pattern is used throughout the entire library. The idea is that you set up a config object and pass that into the initialization routine. The advantage to this system is that the config object can be initialized with logical defaults and new properties added to it without breaking the API.</p> <p>Below and in examples/miniaudio.c is an example of sin wave synthesis that runs smoothly in CJIT:</p> <pre><code>#define MA_NO_DECODING\n#define MA_NO_ENCODING\n#define MINIAUDIO_IMPLEMENTATION\n#include &lt;miniaudio.h&gt;\n#include &lt;stdio.h&gt;\n#define DEVICE_FORMAT       ma_format_f32\n#define DEVICE_CHANNELS     2\n#define DEVICE_SAMPLE_RATE  48000\n\nvoid data_callback(ma_device* pDevice,\n                   void* pOutput,\n                   const void* pInput,\n                   ma_uint32 frameCount) {\n    ma_waveform* pSineWave;\n    MA_ASSERT(pDevice-&gt;playback.channels == DEVICE_CHANNELS);\n    pSineWave = (ma_waveform*)pDevice-&gt;pUserData;\n    MA_ASSERT(pSineWave != NULL);\n    ma_waveform_read_pcm_frames(pSineWave, pOutput, frameCount, NULL);\n    (void)pInput;   /* Unused in this example. */\n}\n\nint main(int argc, char** argv) {\n    ma_waveform sineWave;\n    ma_device_config deviceConfig;\n    ma_device device;\n    ma_waveform_config sineWaveConfig;\n    deviceConfig = ma_device_config_init(ma_device_type_playback);\n    deviceConfig.playback.format   = DEVICE_FORMAT;\n    deviceConfig.playback.channels = DEVICE_CHANNELS;\n    deviceConfig.sampleRate        = DEVICE_SAMPLE_RATE;\n    deviceConfig.dataCallback      = data_callback;\n    deviceConfig.pUserData         = &amp;sineWave;\n    if (ma_device_init(NULL, &amp;deviceConfig, &amp;device) != MA_SUCCESS) {\n        printf(\"Failed to open playback device.\\n\");\n        return -4;\n    }\n    printf(\"Device Name: %s\\n\", device.playback.name);\n    sineWaveConfig = ma_waveform_config_init(device.playback.format,\n                                             device.playback.channels,\n                                             device.sampleRate,\n                                             ma_waveform_type_sine,\n                                             0.2, 220);\n    ma_waveform_init(&amp;sineWaveConfig, &amp;sineWave);\n    if (ma_device_start(&amp;device) != MA_SUCCESS) {\n        printf(\"Failed to start playback device.\\n\");\n        ma_device_uninit(&amp;device);\n        return -5;\n    }\n    printf(\"Press Enter to quit...\\n\");\n    getchar();\n    ma_device_uninit(&amp;device);\n    (void)argc;\n    (void)argv;\n    return 0;\n}\n</code></pre>"},{"location":"sound/#next-filesystem-operations","title":"\u23e9 Next: filesystem operations","text":"<p>Go to the next chapter of this tutorial.</p>"},{"location":"tui/","title":"Terminal User Interface","text":"<p>Believe it or not, one can draw a beautiful terminal user interface (also called TUI) on a text console, with colors and blinking lights too. Our choice is to use termbox2 whose API that improves a lot on old approaches as ncurses or slang, by sucking much less <code>:^)</code></p> <p>Here is a quick synopsis:</p> <pre><code>#define TB_IMPL\n#include \"termbox2.h\"\n\nint main(int argc, char **argv) {\n    struct tb_event ev;\n    int y = 0;\n\n    tb_init();\n\n    tb_printf(0, y++, TB_GREEN, 0, \"hello from termbox\");\n    tb_printf(0, y++, 0, 0, \"width=%d height=%d\",\n              tb_width(), tb_height());\n    tb_printf(0, y++, 0, 0, \"press any key...\");\n    tb_present();\n\n    tb_poll_event(&amp;ev);\n\n    y++;\n    tb_printf(0, y++, 0, 0, \"event type=%d key=%d ch=%c\",\n              ev.type, ev.key, ev.ch);\n    tb_printf(0, y++, 0, 0, \"press any key to quit...\");\n    tb_present();\n\n    tb_poll_event(&amp;ev);\n    tb_shutdown();\n\n    return 0;\n}\n</code></pre> <p>The termbox2 basic API is self explanatory:</p> <pre><code>int tb_init();\nint tb_shutdown();\n\nint tb_width();\nint tb_height();\n\nint tb_clear();\nint tb_present();\n\nint tb_set_cursor(int cx, int cy);\nint tb_hide_cursor();\n\nint tb_set_cell(int x, int y, uint32_t ch,\n                uintattr_t fg, uintattr_t bg);\n\nint tb_peek_event(struct tb_event *event,\n                  int timeout_ms);\nint tb_poll_event(struct tb_event *event);\n\nint tb_print(int x, int y,\n             uintattr_t fg, uintattr_t bg,\n             const char *str);\nint tb_printf(int x, int y,\n              uintattr_t fg, uintattr_t bg,\n              const char *fmt, ...);\n</code></pre> <p>To see a demo of what it can do, see the examples/termbox.c example which will draw a keyboard on your terminal and show the keys you are pressing in real-time. Its code is a great source of knowledge about what termbox2 can do!</p>"}]}